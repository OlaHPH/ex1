## h4 Uryyb Greb

<details><summary>x) Read and summarize - TBC (This subtask x does not require tests with a computer. Some bullets per article is enough for your summary, feel free to write more if you like)
        â‚¬ Schneier 2015: Applied Cryptography: 10. Using Algorigthms: 10.1, 10.2, 10.3, 10.4 (from start until the start of "Dereferencing Keys" in 10.4)</summary>
<p>
        
The security of the whole system (data, communication, information, etc. security) is as strong as the weakest link, therefore every element (algorithm, protocol, key management, etc) has to be secure. 

Cryptography is only a very small part of the system - the mathematics of making the system secure. People sometimes focus only on its length while neglect the other aspects. Example: it's much easier to steal data from so's computer by breaking and installing a camera recording computer screen than cryptanalze the hard drive. 

Additionally, the "spy versus spy" cryptography technology is so obsolete as over 99% used in daily operations (bank cards, pay-TV, office building, computer access token, prepayment electricity meter, etc.). In these applications, cryptography role is minor. NSA (National Security Agency) admitted that most securities failures are not because of algorithms or protocol failures, but mainly due to other implementation failures (personel with harmful intention, faulty implementation, integration blunders, etc.) 
                    
*10.1 Choosing an algorithm

 Available options, all listed below have some issues, 
        * published algorithm (ground: as it's out there and already tested by the crytographer and survived) - most sensible option 
        * manufacturer (ground: they get to protect their reputation)
        * private consultant (ground: they know things)
        * the government (ground: the gov protects its citizen interest)
        * using their own algorithms (ground: the best, and self trust) 

 The algorithms in this book are public and listed with results, both positive and negative with exception of military cryptanalysis - no access. 
 
Algorithms for Export 
* must be approved by the US gov (or actually the NSA - National Security Agency). NSA gets a copy of the source code, but the algorithm's details stay in secret. 
* Non-official practices: 
  * leak a key bit once in a while, embedded in the ciphertext
  * fit the effective key within 30 bit range, example: while the algorithm may accept a 100-bit key, most of those keys might be equivalent (???) 
  * use a fix IV, or encrypt a fixed header at the beginning of each encrypted msg (known-plaintext attack)
  * generate few random bytes, encrypt them with the key, put both the plaintext and ciphertext of those random bytes at the beginning of the encrypted message (known-plaintext attack). 
           
*10.2 Public-key cryptography versus symmetric cryptography
        
 Note: terms briefly explained in 1 Foudations, 1.1 Terminology (see Note to self below) 
 
 Both have their own strength and weakness - they are different and solve different problems. 
 Symmetric cryptogaphy is best for encrypting data while public-key outshines in key management and protocols.   
        
*10.3 Encrypting communication channels  
 
 OSI models (Open Systems Inconnection) consists of 7 layers - 1. physical, 2. data link, 3. network, 4. transport, 5. session, 6. presentation, 7. application according to [Imperva OSI Model](https://www.imperva.com/learn/application-security/osi-model/)
 * Link-to-link encryption (lowest layers - 1. physical and 2. data link) - 
  * plus - the easiest place to add encryption (generally standardized, easy to connect hadware encryption devices), effective encryption (traffic-flow security - hacker cannot get access to the information, where and how much information is being transferred). Security does NOT depend on any traffic management techniques. Key management is also simple, only 2 endpoints of the line need A COMMON key, and they can change their key independently from the rest of the network, encryption is online
  * minus - EACH physical link in the network needs to be encrypted, leaving any link unencrypted would affect the security of the entire network. Additionally, every node in the network must be protected, since it processes unencrypted data.  
        
 * End-to-end encryption (3. network and 4. transport layers) - encryption device must understand the data according to the protocols up to layer 3. network and encrypt only the transport data units, which are then recombined with the unencrypted routing information and sent to lower layers for transmission (???)
  * plus - avoid encryption/ decryption problem at the physical layer (link-to-link encryption), data remains encrypted until it reaches the final destination.    
  * minus -  prone to traffic analysis (routing information for the data is not encrypted, hacker can learn who communicate to whom, what time, how long WIHOUT knowing contents of these converstaions). Key management is more difficult as individual users must be sure they have common keys, encryption is offline. 

        Combining the two -  most expensive but most effective way of securing a network. link-to-link encrypion assure traffic-flow-security, and end-to-end reduces the threat of unencrypted data at the various nodes in the network. Key management for the two schemes can be completely separate: at the physical level (link-to-link) by the network manager and users (end-to-end) encryption. 
        
*10.4 Encrypting data for storage (???) - this part is much more challenging to go through comparing to previous 3 

Example: A sends herself a message *in the future* - different problem opened. 
In communication channels, messages in transit have no intrinsic (real) value. If A sends B a message, and B doesn't receive the message, A can resend it. NOT for data encrypted for storage. Getting back to the example, A sends her future self a message in the future, and cannot decrypt her own message, she cannot go back in time and decrypt it - it is lost. 

The encryption key has the same value as the message, only smaller. Cryptography breaks large secres into smaller pieces which can be easily lost. Key management procedures: same keys will be used many times, and data may stay on a disk for a while before being decrypted. Note that communication link keys ideally should exist only for the length of communication. For data storage keys, that can be for years, so the keys have to be stored securely for years.

Other issues: 
* multiple forms of data exists in different locations -> more prone to known-plaintext attack (see brief explanation in 1 Foudations, 1.1 Terminology - as in Note to self below)
* for DB app, pieces of data may be smaller than the block size of most algorithms ->  encrypted data is bigger than the original. 
* speed of I/O devices asks for fast EnC/DeC, and may require encryption hardware, or special algorithm 
* safe, long-term storage for keys required
* key management is muc more complicated for different users with different privileges
        
Retrieval for encrypted non-structured text files is easier, while for database is much problematic (decrypt the whole DB to access a single record inefficient vs encrypt records independently proning to block-replay attack). On top of that, unencrypted file(s) must be erased after encryption.  
     
     
* Note to self: 
        Although not required, I find reading chapter 1  Foundations, 1.1 Terminology provides a general overview and understanding of the most often used terminology in this book. From those: 
 * plaintext (cleartext) - original message (M)
 * encryption - the practice/act/process of disguise the msg to hide its subtance (E) vs decryption (D)
 * ciphertext - encrypted message (C)
 * cryptanalysis - art and science of breaking encrypted (ciphertext) message
 * cipher (cryptographic algorithm) - mathematical function used for encryption (E) and decryption (D) 
 * cryptosytem = algorithm + plaintexts (M) + ciphertexts (C) + keys (K) 
 * symmetric algorithm (conventional algorithm) - encryption key can be calculated from decryption key and vice versa. Usually, encryption key = decryption key (aka. secret-key algorithm, single-key algorithm, or one-key algorithm). Sender and receiver have to agree on a key BEFORE they can communicate securely. So, the key must remain secret in order to keep the communication secret. SA can be divided into stream algorithm and block algorithm. 
 * public-key algorithm (asymetric algorithm) - encryption key (public key) <> decryption key (private key), and decryption key CANNOT be calculated from encryption key which can be made public.
 * ciphertext-only attack - the hacker has access to several ciphertexts (encrypted messages) with the same encryption algorithm, he tries to recover as many plaintexts as possible, or even try to find out the encryption key to decrypt other ciphertexts with the same keys. 
 * known-plaintext attack - the hacker has access to several plaintext messages and their corresponding ciphertexts, he tries to find out the encryption key/algorithm to decrypt any NEW ciphertexts encrypted with the same keys. 
 * chosen-plaintext attack 
 * adaptive-chosen plaintext attack  
 * chosen-ciphertext attack
 * block-replay attack (???) 
</p>
</details>
<details><summary>y) Choose a password manager. Explain: - TBC (This subtask y does not require tests with a computer if the question can be answered without them)</summary>
<p>
  
* What treaths does it protect against?
* What information is encrypted, what's not?
* What's the license? How would you describe license's effects or categorize it?
* Where is the data stored? If in "the cloud", which country / juristiction / which companies? If on local disk, where?
* How is the data protected?
  </p>
  </details>
<details><summary>a) Demonstrate the use of a password manager.- TBC </summary>
  <p>
  </p>
</details>
<details><summary>b) Encrypt and decrypt a message (you can use any tool you want, gpg is one option)- TBC </summary>
  <p>
  </p>
</details>
<details><summary>c) Voluntary bonus: send and receive encrypted message over email.- TBC </summary>
  <p>
  </p>
</details>
<details><summary> d) Voluntary difficult bonus, requries coding skills: Cryptopals (recommended, if you have what it takes).- TBC </summary>
  <p>
  </p>
</details>
 <details><summary>   e) Voluntary bonus, easy: try rot13, the military grade top-secret encryption of the top-2 empire of year zero. 
  Could double rot13 provide extra security?- TBC </summary>
  <p>
  </p>
</details>

## References 
* [Information Security course taught by Tero Karvinen](https://terokarvinen.com/2023/information-security-2023/)
* [OSI Model](https://www.imperva.com/learn/application-security/osi-model/)
 

